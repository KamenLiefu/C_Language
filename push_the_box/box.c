#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>//系统调用的封装，提供POSIX操作系统API
#include <stdbool.h>
#include <termio.h>

/*功能同<conio.h>头文件
 *用于控制台的输入输出
 *用户通过按键盘产生对应的操作，如getch()函数
 */
int getch(void)//从键盘上读入字符不回显，直接操作
{
	struct termios tm, tm_old;
	int fd = 0, ch;

	if (tcgetattr(fd, &tm) < 0) {//保存现在的终端设置
		return -1;
	}

	tm_old = tm;//定义tm_old类型的tm
	cfmakeraw(&tm);//更改终端设置为原始模式，该模式下所有的输入数据以字节为单位被处理
	if (tcsetattr(fd, TCSANOW, &tm) < 0) {//设置上更改之后的设置
		return -1;
	}

	ch = getchar();//从键盘上读入一个字符,并回显，按回车键结束
	if (tcsetattr(fd, TCSANOW, &tm_old) < 0) {//更改设置为最初的样子
		return -1;
	}

	return ch;
}
int step = 0;//定义游戏步数的初始值
void exit_soko();//数据文件关闭函数声明
void keyDown();//按键控制函数声明

/*创建三维数组，
 * 在构造二维数组地图
 * 基础上构建关卡功能
 */
int  map[5][14][28] =
{
	/*0:空 1:#  墙
	  3:0  4:$ 目的地和箱子
	  5:@  小人
	  7:m  箱子推到目的地
	  8:@  人和目的在一起
	 */

{
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,
1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,
1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,5,0,0,0,0,4,0,3,1,
1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,3,1,
1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,3,1,
1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},

   {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
	1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
	1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,
	1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,
	1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,3,0,0,0,0,0,1,1,1,1,
	1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
	1,0,0,1,0,0,0,0,0,0,0,0,0,0,1,4,0,0,0,0,1,0,0,0,0,0,1,1,
	1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,3,0,0,0,0,1,
	1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,4,0,0,0,1,0,0,0,1,1,
	1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
	1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,
	1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,
	1,0,0,0,0,0,0,0,0,0,0,0,0,3,0,4,0,5,0,0,0,0,0,0,1,1,1,1,
	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,},

   {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
	1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,
	1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,
	1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,1,
	1,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,
	1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,
	1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,4,0,3,0,1,1,
	1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
	1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,4,0,0,0,1,0,0,1,1,1,
	1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,4,0,0,3,0,0,0,0,0,0,0,1,
	1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,
	1,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,4,0,3,1,1,1,1,
	1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,4,0,0,0,0,0,0,0,1,1,1,
	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,},

   {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
	1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,4,0,0,0,0,0,0,1,
	1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,
	1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
	1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,1,1,1,
	1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,
	1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,1,1,
	1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,1,1,
	1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,4,0,0,0,1,0,0,1,
	1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,3,1,1,
	1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
	1,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,4,0,3,1,1,1,
	1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,4,0,0,0,0,0,1,1,1,
	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},

   {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
	1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,4,0,3,0,0,0,0,0,0,1,
	1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,
	1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,
	1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,4,0,0,3,0,0,1,1,1,1,
	1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
	1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,1,1,
	1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,1,1,
	1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,4,0,1,0,0,1,
	1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,3,0,0,0,0,1,
	1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
	1,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,3,0,0,0,0,0,1,
	1,0,0,0,0,0,0,0,0,0,0,3,0,4,0,0,5,0,0,0,0,0,0,0,0,1,1,1,
	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}

};
int cas = 0;	//为0表示第一关
int boxSum[] = { 3,4,5,6,7 };

//记录每一关的箱子数，或者箱子和目的地在一起的数目
/*地图绘图,
 * 并定义数字代表的含义
 * 使用switch函数进行判断
 */
void drawMap()
{
	for (int i = 0; i < 14; i++)
	{
		for (int j = 0; j < 28; j++)
		{

			switch (map[cas][i][j])
			{
				//0:空1:# :墙
			case 0:
				printf(" ");
				break;
			case 1:
				printf("#");
				break;
				//3：0 4：$  //目的地和箱子
			case 3:
				printf("O");
				break;
			case 4:
				printf("$");
				break;
				//5：@	人
			case 5:
				printf("@");
				break;
			case 7:
				printf("m");
				break;
			case 8:
				printf("@");
				break;
				//7:m	  //目的(3)和箱子(4)在一起
				//8：@	  //人和箱子在一起
			}
		}
		printf("\n");
	}
}
/*开始数据加载
 * 标准I/O打开流文件
 * 并且定义为可读写的打开方式
 * 若文件不存在则会创建该文件
 * 若文件存在则文件长度为0
 * 擦除文件以前的内容
 */
void start_soko(void)
{
	FILE* frp = fopen("soko.bin", "w+");
	if (NULL == frp)
	{
		printf("数据加载错误!\n");
		return;
	}
	/* fread函数第一个参数是存放读入记录的缓冲区
	 *第二个参数是size 读取的每个记录的大小
	 *第三个参数是nmemb 读取的记录数
	 *第四个参数是要读取的文件流
	 */
	fread(map, 1, 490, frp);

	fclose(frp);//关闭文件流
}
/*游戏进程结束函数
 * 标准I/O打开流文件
 * 并定义为可读写的打开方式
 */
void exit_soko(void)
{
	FILE* fwp = fopen("soko.bin", "w+");
	printf("游戏结束，退出游戏");
	if (NULL == fwp)
	{
		printf("数据保存错误!\n");
	}
	/*第一个参数是存放写入记录的缓冲区
	 * 第二个参数是size 写入的每个记录的大小
	 * 第三个参数是 nmemb写入的记录数
	 * 第四个参数是要写入的文件流
	 */
	fwrite(map, 1, 490, fwp);
	fclose(fwp);
	/*exit()函数在终止进程之前
	 * 要检查打开了那些文件
	 * 并把文件缓冲区的内容写回文件
	 * exit(0)表示正常结束
	 */
	exit(0);
}
//按键处理
void keyDown()
{
	//分析按键过程
	//定位人在哪里
	int i, j;//定义整型变量i，j
	//i表示行，j表示列
	for (i = 0; i < 14; i++)
	{
		for (j = 0; j < 28; j++)
		{
			if (map[cas][i][j] == 5 || map[cas][i][j] == 8)
				//如果此时内层是小人或者小人和箱子在一起
				break;//beak只能跳出一条语句
		}
		if (map[cas][i][j] == 5 || map[cas][i][j] == 8)
			//如果此时外层是小人或者小人和箱子在一起
			break;//break只能跳出一条语句
	}

	char ch = getch();	//从键盘键入字符不回显
	switch (ch)
	{
		//小键盘码值：72上 80下   75左 77右
	case 'w':
	case 'W':
	case 72:
		//下一个地方等于空地或者是目的 能走
		if (7 == map[cas][i - 1][j])
			//如果此时箱子已经到达目的地，则小人无法推动
		{
			return;
		}
		//如果是空地或者目的地
		if (map[cas][i - 1][j] == 0 || map[cas][i - 1][j] == 3)
		{
			//走的实质是交换连个位置的值
			//原来的地方(map[i-1][j])人（5）走了
			map[cas][i][j] -= 5;
			//新的地方(map[i][j])人（5）来了
			map[cas][i - 1][j] += 5;
			step++;//记录按键步数，按键步数每次加1
		}
		//相邻的地方
		if (map[cas][i - 1][j] == 4 || map[cas][i - 1][j] == 7)
		{
			//相邻的地方的相邻
			if (map[cas][i - 2][j] == 0 || map[cas][i - 2][j] == 3)
			{       //怎么走？三步
				//原来的地方
				map[cas][i][j] -= 5;
				//相邻
				map[cas][i - 1][j] += 1;
				//隔壁的隔壁
				map[cas][i - 2][j] += 4;
				step++;
			}

		}

		break;
	case 's':
	case 'S':
	case 80:
		//下一个地方等于箱子和目的地在一起
		//小人推不动
		if (map[cas][i + 1][j] == 7)
		{
			return;
		}
		//如果是空地或目的地
		if (map[cas][i + 1][j] == 0 || map[cas][i + 1][j] == 3)
		{
			//走的实质交换连个位置的值
			//原来的地方(map[i-1][j])人（5）走了
			map[cas][i][j] -= 5;
			//新的地方(map[i][j])人（5）来了
			map[cas][i + 1][j] += 5;
			step++;//每次按键步数加1
		}
		//相邻的地方
		//如果是箱子或者箱子和目的地在一起
		if (map[cas][i + 1][j] == 4 || map[cas][i + 1][j] == 7)
		{
			//相邻的地方的相邻
			//如果相邻的相邻是空地或者是目的地
			if (map[cas][i + 2][j] == 0 || map[cas][i + 2][j] == 3)
			{
				//怎么走，三步
				//原来的地方
				map[cas][i][j] -= 5;
				//相邻
				map[cas][i + 1][j] += 1;
				//隔壁的隔壁
				map[cas][i + 2][j] += 4;
				step++;//记录按键的次数，每次按键加1
			}

		}
		break;

	case 'a':
	case 'A':
	case 75:
		//下一个地方等于箱子和目的地在一起
		//小人推不动
		if (map[cas][i][j - 1] == 7)
		{
			return;
		}
		//如果是空地或者目的地
		if (map[cas][i][j - 1] == 0 || map[cas][i][j - 1] == 3)
		{
			//走的实质交换连个位置的值
			//原来的地方(map[i-1][j])人（5）走了
			map[cas][i][j] -= 5;
			//新的地方(map[i][j])人（5）来了
			map[cas][i][j - 1] += 5;
			//j+=5  j=j+5
			step++;//每次按键步数加1

		}
		//如果是箱子或者箱子和目的地在一起
		if (map[cas][i][j - 1] == 4 || map[cas][i][j - 1] == 7)
		{
			//做箱子的下一个地方判断能不能走
			//如果是空地或者目的地在一起
			if (map[cas][i][j - 2] == 0 || map[cas][i][j - 2] == 3)
			{
				//原来的地方
				map[cas][i][j] -= 5;
				//相邻
				map[cas][i][j - 1] += 1;
				//隔壁的隔壁
				map[cas][i][j - 2] += 4;
				step++;//每次按键步数加1
			}

		}

		break;
	case 'D':
	case 'd':
	case 77:
		//下一个地方等于箱子和目的地在一起
		//小人推不动
		if (map[cas][i][j + 1] == 7)
		{
			return;
		}
		//如果是空地或者目的地能走
		if (map[cas][i][j + 1] == 0 || map[cas][i][j + 1] == 3)
		{
			//原来的地方(map[i-1][j])人（5）走了
			map[cas][i][j] -= 5;
			//新的地方(map[i][j])人（5）来了
			map[cas][i][j + 1] += 5;
			step++;
		}

		//下一个地方是箱子，判断箱子的下一个地方是不是目的和空地
		if (map[cas][i][j + 1] == 4 || map[cas][i][j + 1] == 7)
		{
			//做箱子的下一个地方判断能不能走
			if (map[cas][i][j + 2] == 0 || map[cas][i][j + 2] == 3)
			{
				//原来的地方
				map[cas][i][j] -= 5;
				//相邻
				map[cas][i][j + 1] += 1;
				//隔壁的隔壁
				map[cas][i][j + 2] += 4;
				step++;
			}

		}
		break;
	case 'Q':
	case 'q':
		//游戏退出
		//通过调用游戏退出
		//关闭文件流，结束游戏
		exit_soko();
	}

}
//获胜及游戏进入下一关判断
//判断箱子的数目或者箱子到达目的的个数
//或者判断箱子和目的地在一起的个数
int gameOver()
{
	int count = 0;
	//所有的地方找一遍
	for (int i = 0; i < 14; i++)
	{
		for (int j = 0; j < 28; j++)
		{
			if (map[cas][i][j] == 7)
				//如果等于箱子和目的地在一起，说明完成任务
				count++;//每完成一个任务数量加1
		}
	}
	return count;//比较完成任务数与关卡挑战的数量
	//如果相等则获胜，其他则失败
}
//多关开问题
int cum() {
	int i, j, wall = 0;//箱子还能走通
	for (i = 0; i < 14; i++) {
		for (j = 0; j < 28; j++) {
			if (map[cas][i][j] == 4);//如果位置等于箱子
		}
	}//遍历整个地图
}//计算地图中有多少个终点
//判断游戏失败退出函数
int lose() {
	int i, j;
	int wall = 0;
	for (i = 0; i < 14; i++) {
		for (j = 0; j < 28; j++) {
			if (i > 0 && j > 0) {
				//如果等于箱子或者箱子和目的地在一起	
				if (map[cas][i][j] == 4 || map[cas][i][j] == 7) {
					//六种情况，上下，上左，上右，下左，下右
					//如果有一种情况发生，说明箱子走入死胡同，
					//宣告游戏失败，退出游戏
					if (((map[cas][i - 1][j] == 1 || map[cas][i - 1][j] == 4 || map[cas][i - 1][j] == 7) && (map[cas][i][j - 1] == 1 || map[cas][i][j - 1] == 4 || map[cas][i][j - 1] == 7))
						|| ((map[cas][i - 1][j] == 1 || map[cas][i - 1][j] == 4 || map[cas][i - 1][j] == 7) && (map[cas][i + 1][j] == 1 || map[cas][i + 1][j] == 4 || map[cas][i + 1][j] == 7))
						|| ((map[cas][i][j - 1] == 1 || map[cas][i][j - 1] == 4 || map[cas][i][j - 1] == 7) && (map[cas][i][j + 1] == 1 || map[cas][i][j + 1] == 4 || map[cas][i][j + 1] == 7))
						|| ((map[cas][i][j - 1] == 1 || map[cas][i][j - 1] == 4 || map[cas][i][j - 1] == 7) && (map[cas][i + 1][j] == 1 || map[cas][i + 1][j] == 4 || map[cas][i + 1][j] == 7))
						|| ((map[cas][i + 1][j] == 1 || map[cas][i + 1][j] == 4 || map[cas][i + 1][j] == 7) && (map[cas][i][j + 1] == 1 || map[cas][i][j + 1] == 4 || map[cas][i][j + 1] == 7))
						|| ((map[cas][i][j + 1] == 1 || map[cas][i][j + 1] == 4 || map[cas][i][j + 1] == 7) && (map[cas][i - 1][j] == 1 || map[cas][i - 1][j] == 4 || map[cas][i - 1][j] == 7))) {
						wall++;
					}
				}
			}
		}
	}
	if (wall == cum())
	{
		wall = 1;//如果此时箱子走入死路
	}
	return wall;//返回1说明游戏失败
}
//主函数程序
int main()
{
	start_soko();//数据文件加载
	while (1)
	{
		printf("\t\t   第【%d】关\n", cas + 1);//游戏获胜进入下一关
		drawMap();//绘制地图模块
		if (gameOver() == boxSum[cas])//如果本关游戏获胜
		{
			cas++;//第一关通过，关卡变为第二关
			printf("恭喜你完成本关! 所使用的步数%d\n", step);
			if (cas == 5)//如果关数加到5，说明游戏已经全部挑战完成
				break;
		}
		keyDown();//按键函数
		system("clear");//清屏
		if (1 == lose())
		{
			system("clear");//游戏失败，退出程序
			printf("游戏失败！\n");
			exit_soko(); return 0;
		}
	}
	exit_soko();//游戏全部挑战完成，退出程序
	printf("\n\n\t\tGameOVer");
	system("pause");
	return 0;
}
